Total: 752 samples
     579  77.0%  77.0%      752 100.0% run
     104  13.8%  90.8%      104  13.8% SortedList_lookup
      69   9.2% 100.0%       69   9.2% SortedList_insert
       0   0.0% 100.0%      752 100.0% ?? /usr/src/debug////////glibc-2.17-c758a686/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:118
       0   0.0% 100.0%      752 100.0% start_thread
ROUTINE ====================== run in /u/cs/ugrad/alexandy/Desktop/cs-111/lab2b/lab2_list.c
   579    752 Total samples (flat / cumulative)
     .      .   99: 
     .      .  100: long long calc_time_diff(struct timespec start, struct timespec end) {
     .      .  101:     return 1000000000L * (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec);
     .      .  102: }
     .      .  103: 
---
     .      .  104: void *run(void *threadid) {
     .      .  105:     long tid = (long) threadid;
     .      .  106:     long offset = tid * n_iters;
     .      .  107:     struct timespec start_tp, end_tp;
     .      .  108: 
     .      .  109:     for(long i=0; i<n_iters; i++) {
     .      .  110:         const char* key = pool[i+offset].key;
     .      .  111:         int idx = (*key) % n_lists;
     .      .  112: 
     .      .  113:         if(opt_sync == M_SYNC) {
     .      .  114:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
     .      .  115:             pthread_mutex_lock(&mutexes[idx]);
     .      .  116:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  117:         } else if(opt_sync == S_SYNC) {
     .      .  118:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
   349    349  119:             while(__sync_lock_test_and_set(&spinlocks[idx], 1) == 1);
     .      .  120:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  121:         }
     .      .  122: 
     .     69  123:         SortedList_insert(&lists[idx], &pool[i+offset]);
     .      .  124: 
     .      .  125:         if(opt_sync == M_SYNC) {
     .      .  126:             pthread_mutex_unlock(&mutexes[idx]);
     .      .  127:         } else if(opt_sync == S_SYNC) {
     .      .  128:             __sync_lock_release(&spinlocks[idx]);
     .      .  129:         }
     .      .  130: 
     .      .  131:         wait_time[tid] += calc_time_diff(start_tp, end_tp);
     .      .  132:     }
     .      .  133: 
     .      .  134:     for(int i=0; i<n_lists; i++) {
     .      .  135:         if(opt_sync == M_SYNC) {
     .      .  136:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
     .      .  137:             pthread_mutex_lock(&mutexes[i]);
     .      .  138:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  139:         } else if(opt_sync == S_SYNC) {
     .      .  140:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
     .      .  141:             while(__sync_lock_test_and_set(&spinlocks[i], 1) == 1);
     .      .  142:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  143:         }
     .      .  144: 
     .      .  145:         SortedList_length(&lists[i]);
     .      .  146: 
     .      .  147:         if(opt_sync == M_SYNC) {
     .      .  148:             pthread_mutex_unlock(&mutexes[i]);
     .      .  149:         } else if(opt_sync == S_SYNC) {
     .      .  150:             __sync_lock_release(&spinlocks[i]);
     .      .  151:         }
     .      .  152: 
     .      .  153:         wait_time[tid] += calc_time_diff(start_tp, end_tp);
     .      .  154:     }
     .      .  155: 
     .      .  156:     for(long i=0; i<n_iters; i++) {
     .      .  157:         const char* key = pool[i+offset].key;
     .      .  158:         long idx = *key % n_lists;
     .      .  159: 
     .      .  160:         if(opt_sync == M_SYNC) {
     .      .  161:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
     .      .  162:             pthread_mutex_lock(&mutexes[idx]);
     .      .  163:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  164:         } else if(opt_sync == S_SYNC) {
     .      .  165:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
   229    229  166:             while(__sync_lock_test_and_set(&spinlocks[idx], 1) == 1);
     1      1  167:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  168:         }
     .      .  169: 
     .    104  170:         SortedListElement_t *elem = SortedList_lookup(&lists[idx], key);
     .      .  171:         if(elem == NULL) {
     .      .  172:             fprintf(stderr, "Error: element that should have been in list was not found\n");
     .      .  173:             exit(2);
     .      .  174:         } else if(SortedList_delete(elem) == 1) {
     .      .  175:             fprintf(stderr, "Error: corrupted pointer(s) in list found\n");
     .      .  176:             exit(2);
     .      .  177:         }
     .      .  178: 
     .      .  179:         if(opt_sync == M_SYNC) {
     .      .  180:             pthread_mutex_unlock(&mutexes[idx]);
     .      .  181:         } else if(opt_sync == S_SYNC) {
     .      .  182:             __sync_lock_release(&spinlocks[idx]);
     .      .  183:         }
     .      .  184: 
     .      .  185:         wait_time[tid] += calc_time_diff(start_tp, end_tp);
     .      .  186:     }
     .      .  187:     return NULL;
     .      .  188: }
---
     .      .  189: 
     .      .  190: int main(int argc, char *argv[]) {
     .      .  191: 
     .      .  192:     const struct option long_options[] = {
     .      .  193:         {"threads", required_argument, 0, 't'},
ROUTINE ====================== run in /u/cs/ugrad/alexandy/Desktop/cs-111/lab2b/lab2_list.c
   579    752 Total samples (flat / cumulative)
     .      .   99: 
     .      .  100: long long calc_time_diff(struct timespec start, struct timespec end) {
     .      .  101:     return 1000000000L * (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec);
     .      .  102: }
     .      .  103: 
---
     .      .  104: void *run(void *threadid) {
     .      .  105:     long tid = (long) threadid;
     .      .  106:     long offset = tid * n_iters;
     .      .  107:     struct timespec start_tp, end_tp;
     .      .  108: 
     .      .  109:     for(long i=0; i<n_iters; i++) {
     .      .  110:         const char* key = pool[i+offset].key;
     .      .  111:         int idx = (*key) % n_lists;
     .      .  112: 
     .      .  113:         if(opt_sync == M_SYNC) {
     .      .  114:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
     .      .  115:             pthread_mutex_lock(&mutexes[idx]);
     .      .  116:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  117:         } else if(opt_sync == S_SYNC) {
     .      .  118:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
   349    349  119:             while(__sync_lock_test_and_set(&spinlocks[idx], 1) == 1);
     .      .  120:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  121:         }
     .      .  122: 
     .     69  123:         SortedList_insert(&lists[idx], &pool[i+offset]);
     .      .  124: 
     .      .  125:         if(opt_sync == M_SYNC) {
     .      .  126:             pthread_mutex_unlock(&mutexes[idx]);
     .      .  127:         } else if(opt_sync == S_SYNC) {
     .      .  128:             __sync_lock_release(&spinlocks[idx]);
     .      .  129:         }
     .      .  130: 
     .      .  131:         wait_time[tid] += calc_time_diff(start_tp, end_tp);
     .      .  132:     }
     .      .  133: 
     .      .  134:     for(int i=0; i<n_lists; i++) {
     .      .  135:         if(opt_sync == M_SYNC) {
     .      .  136:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
     .      .  137:             pthread_mutex_lock(&mutexes[i]);
     .      .  138:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  139:         } else if(opt_sync == S_SYNC) {
     .      .  140:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
     .      .  141:             while(__sync_lock_test_and_set(&spinlocks[i], 1) == 1);
     .      .  142:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  143:         }
     .      .  144: 
     .      .  145:         SortedList_length(&lists[i]);
     .      .  146: 
     .      .  147:         if(opt_sync == M_SYNC) {
     .      .  148:             pthread_mutex_unlock(&mutexes[i]);
     .      .  149:         } else if(opt_sync == S_SYNC) {
     .      .  150:             __sync_lock_release(&spinlocks[i]);
     .      .  151:         }
     .      .  152: 
     .      .  153:         wait_time[tid] += calc_time_diff(start_tp, end_tp);
     .      .  154:     }
     .      .  155: 
     .      .  156:     for(long i=0; i<n_iters; i++) {
     .      .  157:         const char* key = pool[i+offset].key;
     .      .  158:         long idx = *key % n_lists;
     .      .  159: 
     .      .  160:         if(opt_sync == M_SYNC) {
     .      .  161:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
     .      .  162:             pthread_mutex_lock(&mutexes[idx]);
     .      .  163:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  164:         } else if(opt_sync == S_SYNC) {
     .      .  165:             clock_gettime(CLOCK_MONOTONIC, &start_tp);
   229    229  166:             while(__sync_lock_test_and_set(&spinlocks[idx], 1) == 1);
     1      1  167:             clock_gettime(CLOCK_MONOTONIC, &end_tp);
     .      .  168:         }
     .      .  169: 
     .    104  170:         SortedListElement_t *elem = SortedList_lookup(&lists[idx], key);
     .      .  171:         if(elem == NULL) {
     .      .  172:             fprintf(stderr, "Error: element that should have been in list was not found\n");
     .      .  173:             exit(2);
     .      .  174:         } else if(SortedList_delete(elem) == 1) {
     .      .  175:             fprintf(stderr, "Error: corrupted pointer(s) in list found\n");
     .      .  176:             exit(2);
     .      .  177:         }
     .      .  178: 
     .      .  179:         if(opt_sync == M_SYNC) {
     .      .  180:             pthread_mutex_unlock(&mutexes[idx]);
     .      .  181:         } else if(opt_sync == S_SYNC) {
     .      .  182:             __sync_lock_release(&spinlocks[idx]);
     .      .  183:         }
     .      .  184: 
     .      .  185:         wait_time[tid] += calc_time_diff(start_tp, end_tp);
     .      .  186:     }
     .      .  187:     return NULL;
     .      .  188: }
---
     .      .  189: 
     .      .  190: int main(int argc, char *argv[]) {
     .      .  191: 
     .      .  192:     const struct option long_options[] = {
     .      .  193:         {"threads", required_argument, 0, 't'},
